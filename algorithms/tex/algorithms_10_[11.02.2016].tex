\input{header.tex}

\begin{document}

\section{Лекция 10 от 11.02.2016}

\subsection{Расстояние редактирования (расстояние Левенштейна)}

Пусть у нас есть два слова и мы хотим из первого сделать второе. При этом мы можем произвольно расставлять пробелы и заменять буквы. Например:

\begin{center}
	enewcommand{\arraystretch}{0.7}
	\setlength{\tabcolsep}{1pt}
	\begin{tabular}{cccccc}
		п & е & р & в & о & е \\
		\small{$\downarrow$} & \small{$\downarrow$} & \small{$\downarrow$} & \small{$\downarrow$} & &  \\
		в & т & о & р & о & е 
	\end{tabular}
	\quad
	\begin{tabular}{cccccccccccc}
		\cancel{п} & \cancel{е} & \cancel{р} & \cancel{в} & \cancel{о} & \cancel{е} & & & & & & \\
		& & & & & & \small{$\downarrow$} & \small{$\downarrow$} & \small{$\downarrow$} & \small{$\downarrow$} & \small{$\downarrow$} & \small{$\downarrow$}\\
		& & & & & & в & т & о & р & о & е 
	\end{tabular}
	\quad
	\begin{tabular}{ccccccc}
		& п & е & р & \cancel{в} & о & е \\
		\small{$\downarrow$}& \small{$\downarrow$} & \small{$\downarrow$} & & & & \\
		в & т & о & р & & о & е 
	\end{tabular}
\end{center}

Применяется это почти повсеместно:
\begin{itemize}
	\item Проверка орфографии. Введённое слово сравнивается с теми, которые есть в словаре. Если в слове есть ошибка, то программа предложит заменить слово на наиболее похожее верное слово.
	
	\item Проверка работ на плагиат. Опять же, идёт сравнение фраз с фразами из ранее написанных работ.
	
	\item Также его используют для изучения и сравнения последовательностей ДНК.
\end{itemize}

Теперь формализуем ранее сказанное. Пусть даны строки $s = s_1\ldots s_m$ и $t = t_1\ldots t_n$. Тогда \emph{выравнивание} $M$ --- множество пар $(i,j)$ таких, что $1 \leqslant i \leqslant m, 1 \leqslant i \leqslant m$, при этом:
\[(i_1, j_1)\in M, (i_2, j_2)\in M, i_1 = i_2 \implies j_1 = j_2\]
\[(i_1, j_1)\in M, (i_2, j_2)\in M, i_1 < i_2 \implies j_1 < j_2\]

\emph{Расстояние редактирования (оно же расстояние Левенштейна)} --- минимальное число операций, переводящее $s$ в $t$. Доступные операции --- удаление букв, добавление букв и замена одной буквы на другую.

Сколько вообще существует возможных выравниваний?

Для простоты положим, что \(n = m\).

\begin{itemize}
	\item Так как каждую букву слова можно либо заменить, либо убрать, то их явно не меньше, чем $2^{n}$.
	\item Пусть мы выбрали $k$ букв первого слова, которые будут сопоставлены \(k\) буквам другого слова. Тогда получаем, что есть \((C_{n}^{k})^{2}\) выравниваний для фиксированного \(k\) (так как мы вольны в выборе этих букв). Следовательно, всего существует \(\sum\limits_{k = 0}^{n} (C_{n}^{k})^{2}\) выравниваний.
	\item Или по-другому: есть \(2n\) букв. Из них надо выбрать \(k\) букв первого слова для замены и \(n - k\) букв второго слова для вставки. Тогда существует \(C_{2n}^{n}\) выравниваний.
\end{itemize} 

Пусть $d(s, t)$ --- расстояние редактирования между $s$ и $t$.

Рассмотрим первые буквы слов. У нас есть три варианта
\begin{enumerate}
	\item Удалить $s_1$ и как-то превратить остаток первого слова во второе;
	\item Удалить $t_1$ и превратить первое слово в остаток второго;
	\item Сопоставить $s_1$ и $t_1$ и превратить то, что осталось, друг в друга.
\end{enumerate}

Логично, что нужно выбрать наиболее оптимальный вариант. Тогда значение расстояния будет равно минимальному из этих трёх.

Базовый случай --- когда одно из слов пустое. Тогда достаточно вставить все буквы из непустого слова. Следовательно, $d(w, \text{\enquote{}}) = d(\text{\enquote{}}, w) = |w|$

В итоге получаем, что расстояние Левенштейна определяется следующим образом:
\[d(s_1 \ldots s_m, t_1 \ldots t_n) = 
\begin{cases}
|t|, & s = \text{\enquote{ }} \\
|s|, & t = \text{\enquote{ }} \\
\min\begin{cases}
d(s_1\ldots s_{m - 1}, t_1 \ldots t_n) + 1 \\
d(s_1\ldots s_{m}, t_1 \ldots t_{n - 1}) + 1 \\
d(s_1\ldots s_{m - 1}, t_1\ldots t_{n - 1}) + (s_1=t_1) \\
\end{cases} & \text{иначе}
\end{cases}\]

Составим таблицу размером $(m + 1) \times (n + 1)$, где $T[i][j] = d(s_i\ldots s_m, t_j\ldots t_n)$. Пользуясь базовыми случаями заполним верхнюю строку и правый столбец. Теперь заполним $T[6][6]$, как минимум из \(1+T[6][7], 1+T[7][6] \text{ и } T[7][7]+(s_6 \neq t_6)\). Будем продолжать так до тех пор, пока не дойдём до ячейки \(T[1][1]\), в которой и будет записано искомое расстояние Левенштейна:
\begin{center}
	$\begin{tabular}{c|ccccccc}
	\enquote{} & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
	е  & 5 & 4 & 3 & 2 & 1 & 0 & 1 \\
	о  & 4 & 3 & 2 & 1 & 0 & 1 & 2 \\
	в  & 3 & 3 & 2 & 1 & 1 & 2 & 3 \\
	р  & 4 & 3 & 2 & 2 & 2 & 3 & 4 \\
	е  & 4 & 3 & 3 & 3 & 3 & 4 & 5 \\
	п  & \(\mathbf{4}\) & 4 & 4 & 4 & 4 & 5 & 6 \\
	\hline
	& в & т & о & р & о & е & \enquote{}
	\end{tabular}$
\end{center}

Из данной таблицы видно, что \(d(\text{\enquote{первое}}, \text{\enquote{второе}}) = 4\).

Напишем псевдокод для этого алгоритма:

\begin{algorithm}
	\caption{Нахождение расстояния Левенштейна}
	\begin{algorithmic}[1]
		\Function{EditDistance}{$s, t$}\Comment{$p$ и $q$ --- слова}
		\State create \(T[1..(m + 1), 1..(n + 1)]\)
		\For{\(k \mathrel{:=} 1\) \textbf{to} \(m + 1\)}
			\State \(T[k][n + 1] = m + 1 - k\)
		\EndFor
		\For{\(k \mathrel{:=} 1\) \textbf{to} \(n + 1\)}
			\State \(T[m + 1][k] = n + 1 - k\)
		\EndFor
		\For{\(j \mathrel{:=} n\) \textbf{downto} \(1\)}
			\For{\(i \mathrel{:=} m\) \textbf{downto} \(1\)}
			\State \(T[i][j]:= \min(1+T[i+1][j], 1+T[i][j+1], T[i+1][j+1] + (s[i] \neq t[i]))\)
			\EndFor
		\EndFor
		\State \textbf{return} \(T[1][1]\)
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Данный алгоритм можно улучшить, если рассматривать отдельно случаи, когда две соседние буквы переставлены местами. Тогда 
\[d(s_1 \ldots s_m, t_1 \ldots t_n) = 
\begin{cases}
|t|, & s = \text{\enquote{ }} \\
|s|, & t = \text{\enquote{ }} \\
\min\begin{cases}
d(s_1\ldots s_{m - 1}, t_1 \ldots t_n) + 1 \\
d(s_1\ldots s_{m}, t_1 \ldots t_{n - 1}) + 1 \\
d(s_1\ldots s_{m - 1}, t_1\ldots t_{n - 1}) + (s_1=t_1) \\
d(s_1\ldots s_{m - 2}, t_1 \ldots t_{n - 2}) + 1
\end{cases} & \text{если } s_i = t_{i - 1} \text{ и } s_{i - 1} = t_i \\
\min\begin{cases}
d(s_1\ldots s_{m - 1}, t_1 \ldots t_n) + 1 \\
d(s_1\ldots s_{m}, t_1 \ldots t_{n - 1}) + 1 \\
d(s_1\ldots s_{m - 1}, t_1\ldots t_{n - 1}) + (s_1=t_1) \\
\end{cases} & \text{иначе}
\end{cases}\]
Данная функция называется \emph{расстоянием Дамерау-Левенштейна}.

\subsection{Сравнение алгоритмов}

\[\begin{array}{c|ccc}
    & \text{Интервалы} & \text{Ширина} & \text{Редактирование}\\
    \hline
    \text{Число подзадач}&O(n)&O(n)&O(n^2)\\
    \text{Число подзадач, от которых зависит задача}&2&O(n)&3\\
	\text{Время}&O(n)&O(n^2)&O(n^2)\\
\end{array}\]

\end{document}

\input{header.tex}

\begin{document}

\section*{Оргмоменты}
Одна контрольная~--- контест на реализацию какого-то алгоритма. Пользоваться своим кодом запрещено.

Задача --- привести алгоритм, провести теоретический анализ (доказать его корректность, оценить время работы) и запрограммировать. Сначала сдаётся теория, потом практика.

Экзамен устный.

\[O_{\text{итоговая}} = 0.7 \cdot O_{\text{накопленная}}+0.3 \cdot O_{\text{экзамен}}\]
\[O_{\text{накопленная}} = 0.2 \cdot O_{\text{КР}} + 0.12 \sum\limits_{i = 1}^{5} O_{\text{ДЗ i}} + 0.2 \cdot O_{\text{семинары}}\]

Списывание, как обычно, \emph{не поощряется}. ДЗ предполагается не обсуждать.

\href{http://wiki.cs.hse.ru/}{Здесь} (ссылка слева) можно найти ссылки на ДЗ и краткое содержание лекций.

Автоматов \emph{пока} не предусмотрено.

\textbf{Литература:}
\begin{itemize}
    \item \href{https://yadi.sk/i/1enAa7YHmruFw}{Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К.~--- <<Алгоритмы. Построение и анализ>>}
    \item \href{https://yadi.sk/i/E_0-SVipmrvPz}{Дасгупта С., Пападимитриу Х., Вазирани У.~--- <<Алгоритмы>>}
\end{itemize}

\section*{Лекция 1 от 12.01.2016}

\subsection*{Задача о Ханойских башнях. Три стержня.}
Есть три стержня. На первый стержень нанизано 64 диска, от самого большого к самому маленькому. Задача: переложить все диски на второй стержень. Ограничения:
\begin{itemize}
    \item Диски можно переносить только по одному.
    \item Нельзя класть диск большего диаметра на диск меньшего диаметра.
\end{itemize}

Какой может быть алгоритм?

Варианты из аудитории:
\begin{enumerate}
    \item Полный перебор
    \item Рекурсивный алгоритм.
\end{enumerate}

Рассмотрим такой рекурсивный алгоритм:
\begin{enumerate}
    \item Переложим все диски, кроме $n$-ного, на третий стержень;
    \item Переложим $n$-ный диск с первого на второй стержень;
    \item Переложим все остальные с третьего стержня на второй.
\end{enumerate}

\

Запишем этот алгоритм с помощью псевдокода:

\begin{algorithm}
\caption{Рекурсивный алгоритм решения задачи о Ханойской башне}
\begin{algorithmic}[1]
\Function{Hanoi3}{$n,i,j,k$}\Comment{$n$~--- количество дисков, $i,j,k$~--- номера стержней}
\If{$n > 0$}
    \State \textsc{Hanoi3}($n-1,i,k,j$)
    \State move $i \to j$
    \State \textsc{Hanoi3}($n-1,k,j,i$)
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Нарисуем дерево операций для $n = 3$:
\begin{center}
\begin{forest}
for tree={
    parent anchor=south,
    child anchor=north,
    if n children=0{
      font=\itshape,
      tier=terminal,
    }{},
  }
[{H(3,1,2,3)} [{H(2,1,3,2)} [{H(1,1,2,3)} [$1 \to 2$]]
                            [$1 \to 3$]
                            [{H(1,2,3,1)} [$2 \to 3$]]]
              [$1 \to 2$] 
              [{H(2,3,2,1)} [{H(1,3,1,2)} [$3 \to 1$]]
                            [$3 \to 2$]
                            [{H(1,1,2,3)} [$1 \to 2$]]]]
\end{forest}
\end{center}
Алгоритм, по сути, обходит это дерево в глубину и при этом слева направо, выполняя все перемещения, что встретятся.

Это дерево можно рассматривать, как полное бинарное дерево глубины $n$, если перемещения учитывать не в отдельных листьях, а в родительских узлах. Тогда в каждом узле мы выполняем одно действие, а в полном бинарном дереве $2^n-1$ узлов. Следовательно, выполняется $2^n-1$ перемещение.

Пусть число перемещений для $n$ дисков равно $f(n)$. Тогда верно следующее: \[f(n) = \begin{cases}0, &n=0\\2f(n-1)+1, &n>0\end{cases}\]
\textbf{Свойство:} \textit{$f(n) = 2^n - 1$}
\begin{proof} Докажем это по индукции. База верна, так как $f(0) = 0 = 2^0 - 1$. Теперь пусть предположение верно для $n - 1$, то есть $f(n - 1) = 2^{n - 1} - 1$. Тогда $f(n) = 2f(n - 1) + 1 = 2(2^{n - 1} - 1) + 1 = 2^n - 2 + 1 = 2^n - 1$, что и требовалось доказать. \end{proof}

Можно ли улучшить время работы? Оказывается, что нет.

Рассмотрим некоторый алгоритм. Он рано или поздно должен переложить наибольший диск на второй стержень. Для этого ничего не должно быть на нём и на втором, т.е. все на третьем. А как получить эту конфигурацию? Оптимальным алгоритмом на $n-1$ шаг, что приводит к нашим вычислениям и уже полученному минимальному результату в $2^n-1$.

\begin{minimal_steps}
Задачу о Ханойских башнях нельзя решить за меньшее число шагов, причём решение с таким числом шагов ровно одно.
\end{minimal_steps}
\begin{proof}
По индукции.
\begin{description}
\item[База $(n = 0)$:] очевидно, решить быстрее, чем за 0 шагов нельзя и последовательность такая ровно одна.

\item[Переход $(n - 1 \to n)$:] предположим, что мы доказали это утверждение для $n-1$. Рассмотрим утверждение для $n$. Рано или поздно алгоритму понадобится освободить первые два стержня, чтобы переложить первый диск на второй стержень. Необходимо сделать это одно перекладывание и после вернуть все оптимальным алгоритмом. Итого, опираясь на предположение индукции шагов в оптимальном и единственном решении для $n-1$, нам понадобится $2(2^{n-1} - 1) + 1$ шаг, что и равно $2^n -1$. \qedhere
\end{description}
\end{proof}

Изменим задачу:
\subsection*{Четыре стержня. Обобщение задачи.}
Условие в остальном ровно то же. 
Стала ли задача проще?

Сложнее она точно не стала, т.к. четвёртым можно просто не пользоваться.

Рассмотрев переход от двух к трём, кажется, что должно быть проще; как можно воспользоваться четвёртым?

Предложение: переложить предпоследний отдельно на четвёртый и сэкономить на перекладывании башни из $n-1$, перекладывая вместо неё башню из $n-2$

\begin{algorithm}
\caption{Рекурсивный алгоритм решения задачи о Ханойской башне на 4-х стержнях, версия 1}
\begin{algorithmic}[1]
\Function{Hanoi4}{$n,i,j,k,l$}\Comment{$n$~--- количество дисков, $i,j,k,l$~--- номера стержней}
\If{$n > 0$}
    \State \textsc{Hanoi4}($n-1,i,l,k,j$)
    \State move $i \to k$
    \State move $i \to j$
    \State move $k \to j$
    \State \textsc{Hanoi4}($n-1,l,j,i,k$)
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Построив аналогичное дерево, получим, что в каждом узле три перемещения, а узлов $2^{\lfloor\frac{n}{2}\rfloor} - 1$~--- экономия, но не очень большая.

Построим другой алгоритм:

\begin{algorithm}
\caption{Рекурсивный алгоритм решения задачи о Ханойской башне на 4-х стержнях, версия 2}
\begin{algorithmic}[1]
\Function{Hanoi4}{$n,i,j,k,l$}\Comment{$n$~--- количество дисков, $i,j,k,l$~--- номера стержней}
\If{$n > 0$}
    \State \textsc{Hanoi4}($n-m,i,l,k,j$)
    \State \textsc{Hanoi3}($m,i,j,k$)
    \State \textsc{Hanoi4}($n-m,l,j,i,k$)
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Заметим, что число шагов зависит от $m$. Пусть $n_m=\frac{m(m+1)}{2}$ (если $n$ другое, то на первом шаге выберем такой $m$, чтобы $n-m$ было таким, а дальше на вход будет поступать число такого вида).

Построим дерево алгоритма. Оно также будет полным бинарным деревом. Заметим, что в нём $m$ уровней, так как при каждом шаге $m$ уменьшается на единицу. Это связано с тем, что $n_m - m = \frac{m(m+1)}{2} - m = \frac{(m-1)m}{2} = n_{m-1}$. При этом в узле на $i$-м уровне (нумерация с нуля) проводится $2^{m-i} - 1$ операция, так как мы пользуемся доказанным ранее алгоритмом для трёх стержней. Тогда на каждом уровне выполняется $2^m - 2^i$ операций. Тогда всего выполняется $\sum\limits_{i=0}^{m-1} (2^m - 2^i) = m2^m - \sum\limits_{i=0}^{m-1} 2^i = (m-1)2^m + 1$ операций.

Пусть число перемещений для $n$ дисков равно $g(n)$. Тогда
\[g(n_m) = \begin{cases}
    0,&m = 0\\
    2g(n_{m-1}) + 2^m - 1,&m > 0
\end{cases}\]

\textbf{Предложение:} $g(n_m) = (m-1)2^m + 1$
\begin{proof}
По индукции. База верна, так как $g(n_0) = 0 = (0 - 1)2^0 + 1 = - 1 + 1$. Теперь допустим, что предположение верно для $n_{m-1}$, то есть $g(n_{m-1}) = (m-2)2^{m-1} + 1$. Тогда $g(n_m) = 2g(n_{m-1}) + 2^m - 1 = (m - 2)2^m + 2 + 2^m - 1 = (m - 1)2^m + 1$.
\end{proof}

Заметим, что при достаточно больших $n$ верно, что $m \approx \sqrt{2n}$. Тогда $g(n) \approx \sqrt{2n} \cdot 2^{\sqrt{2n}}$. Тогда $g(n) = \Theta(\sqrt{n}\cdot2^{\sqrt{2n}})$. $\Theta$ означает (грубо говоря), что функция растёт примерно так же.

Попробуем обобщить этот алгоритм для любого числа стержней:

\begin{algorithm}
\caption{Рекурсивный алгоритм решения задачи о Ханойской башне, общий случай}
\begin{algorithmic}[1]
\Function{Hanoi}{$n,i,j,P$}\Comment{$n$~--- количество дисков, $i,j,$~--- основные стержни}
\State \Comment{$P$~---множество вспомогательных стержней}
\If{$n > 0$}
    \State choose $p \in P$
    \State $R \mathrel{:=} P \setminus p$
    \If{$R = \varnothing$}
        \State \textsc{Hanoi3}($n,i,j,p$)
    \Else
        \State \textsc{Hanoi}($n-m,i,p,R \cup \{j\}$)
        \State \textsc{Hanoi}($m,i,j,R$)
        \State \textsc{Hanoi}($n-m,p,j,R \cup \{i\}$)
    \EndIf
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Пусть для перемещения $n$ дисков с помощью алгоритма на $k$ стержнях ($k \geq 3$) нужно $h(n,k)$ операций. Тогда верно следующее:
\[h(n_m, k) = \begin{cases}
    0& n=0\\
    2^{n_m}-1& n>0, k=3\\
    2h(n_{m-1}, k) + h(m, k-1)& n > 0, k > 3
\end{cases}\]
\end{document}
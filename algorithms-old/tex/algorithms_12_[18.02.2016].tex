\input{header.tex}

\begin{document}

\section*{Лекция 12 от 18.02.2016}

\subsection{Представление графов в памяти компьютера}

Пусть у нас есть граф $G = (V, E)$. Пусть $n = |V|, m = |E|$. Если мы говорим о линейном времени работы, то подразумеваем $\Theta(n+m)$.

Можем заметить, что если наш граф ориентированный, да ещё и с петлями, то $ m \leqslant n^2$. В более привычном случае неориентированного графа без петель, $m \leqslant \frac{n(n-1)}{2}$, но это всё равно $\Theta(n^2)$.

Минимальная же граница для связного графа --- $n-1$, но как правило, для большинства графов можно считать, что $m = \Omega(n)$.

Как можно представить граф в памяти? Самый известный способ --- \emph{матрица смежности}. Представляет она собой матрицу размера $n\times n$, где на пересечении $i$-ой строки и $j$-го столбца стоит 1 тогдjа и только тогда, когда в графе есть ребро $(i, j)$: $A_{ij} = (i, j) \in E$. Проверить существование ребра можно за константное время, просто найдя нужную ячейку таблицы.

Также существует представление \emph{списками смежности} --- используется $n$ списков, где каждой вершине сопоставлен один из них, и в список $N[i]$ входят только те вершины, что связаны с $i$-ой.  Заметим интересную особенности таких списков --- каждое ребро входит ровно в два списка (в один, если мы говорим об ориентированном графе); плюс нужна память на хранение пустых списков, если таковые имеются. 

Выигрыш по памяти у списков смежности, по сравнению с матрицей, очень существенен для \emph{разреженных графов} (граф, где $m= \Theta(n)$ \emph{или около того} (цитата) ). И действительно --- веб-граф, представление всех связей между веб-страницами, имеет миллиарды и мииллиарды вершин. Построить и обрабатывать матрицу такого размера --- вообще довольно нетривиальная задача, но тут это ещё и оверкилл --- большая часть ячеек будет равна 0 --- в среднем на странице несколько десятков ссылок, но никак не миллиарды.
\[
\begin{array}{c|ccc}
    &\text{Память}&(i, j)\in E?&\mathrm{for}\ v \in E\\\hline\\
    \text{Матрица смежности}&\Theta(n^2)&\Theta(1)&\Theta(n)\\
    \text{Списки смежности}&\Theta(m+n)&\Theta(\deg(i))&\Theta(\deg(i))\\
\end{array}
\]

А ещё бывают мультиграфы, где может быть несколько рёбер в одной паре вершин, и взвешенные графы, но оба представления несложно модифицируются для их поддержки.

\subsection{Оценка BFS}

Запишем несколько отличающийся псевдокод:
%\begin{algorithm}
%    \caption{Поиск в ширину}
%    \begin{algorithmic}[1]
%        \Function{BFS}{$G, s$}
%        \State discovered[s]\mathrel{:=} True
%        \For{$v\in V\setminus\left\{ s \right\}$}
%
%        \EndFor
%    \end{algorithmic}
%\end{algorithm}
% СЛООЖНААА

\begin{lstlisting}
BFS(G, s)
    discovered[s] := true
    for v in V\setminus{s} do
        discovered[v] := false
    i := 0
    T := {}
    L[0] := {s}
    while L[i] != {} do
        L[i+1] := {}
        for u in L[i] do
            for (u, v) in E do
                if not discovered[v] then
                    discovered[v] := true
                    T := T\cup{(u, v)}
                    L[i+1] := L[i+1]\cup{v}
        i := i+1
\end{lstlisting}

*тут снова офигительно долгий пример работы алгоритма* 

Алгоритм работает примерно так же, как тот, что мы уже рассмотрели, но теперь он явно демонстрирует ``послойность'' BFS. Сложность алгоритма --- $O(n+m)$; $n$ как минимум потому, что мы создаём $n$ списков; $m$ же берётся из того, что мы рано или поздно посмотрим на все рёбра. Однако эта оценка верна для списков смежности; матрица смежности медленнее перебирает соседей вершины и с ней мы получили бы $O(n^2)$.

\subsection{Оценка DFS}

Тут тоже запишем несколько другой алгоритм:

\begin{lstlisting}
DFS(G, s)
    for v in V do
        explored[v] := false
    S := [s] // stack
    while not empty(S) do
        u := pop(s)
        if not explored[u] then
            explored[u] := true
            for (u, v) in E do
                if not explored[v] then
                    push(v, S)
                    parent[v] := u
\end{lstlisting}

*и ещё одна десятиминутная демонстрация* *А, нет, не успели*

Сложно
\end{document}

\documentclass[a4paper, 12pt]{article}
\usepackage{cmap}           % Пакет для поиска в полученной пдфке
\usepackage[utf8]{inputenc} % Ззамена кодировки файла на utf8
\usepackage[T2A]{fontenc}   % Подключение кодировки шрифтов
\usepackage[russian]{babel} % Использование русского языка 
\usepackage[left=2cm, right=2cm, top=1cm, bottom=2cm]{geometry} % Изменение размеров полей
\usepackage{indentfirst}    % Красная строка в начале текста
\usepackage{amsmath, amsfonts, amsthm, mathtools, amssymb, icomma, units, yfonts}
\usepackage{amsthm} % Пакет для нормального оформления теорем
\usepackage{algorithmicx, algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{esvect}
\usepackage{enumitem}
\usetikzlibrary{calc,matrix}

%Теоремы
%11.01.2016
\newtheorem*{standartbase}{Теорема о стандартном базисе}
\newtheorem*{fulllemma}{Лемма}
\newtheorem*{sl1}{Следствие 1}
\newtheorem*{sl2}{Следствие 2}
\newtheorem*{monotonousbase}{Теорема о монотонном базисе}
\newtheorem*{scheme}{Утверждение 1}
\newtheorem*{n2}{Утверждение 2}
\newtheorem*{zhegalkin}{Теорема Жегалкина}
\newtheorem*{poste}{Теорема Поста}
\newtheorem*{algo1}{Первое свойство алгоритмов}


%18.01.2016
\newtheorem*{theorem}{Теорема}
\newtheorem*{on2n}{Теорема}
\newtheorem*{o2ndivn}{Теорема}
\newtheorem*{existsFgthen2ndivn}{Теорема}

\renewcommand{\qedsymbol}{\textbf{Q.E.D.}}
\newcommand{\definition}{\underline{Определение:} }
\newcommand{\definitionone}{\underline{Определение 1:} }
\newcommand{\definitiontwo}{\underline{Определение 2:} }
\newcommand{\statement}{\underline{Утверждение:} }
\newcommand{\note}{\underline{Замечание:} }

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}



\begin{document}
\title{Дискретная математика. Модуль 3. Лекция 5}
\author{Лекторий ПМИ ФКН 2015-2016\\Гринберг Вадим\\Жижин Пётр\\Пузырев Дмитрий}
\date{8 февраля 2016}

\maketitle

%Дима%
\subsection*{Введение в теорию алгоритмов. Задача вычисления функций. Разрешимость диофантова уравнения.}

В начале отметим, что в последущих задачах мы будем заниматься \textit{возможностью} написания алгоритма, решающего данную задачу, но не его \textit{вычислительной сложностью}.

Перед тем, как дать, собственно, определение \textit{алгоритма}, приведем ряд показательных примеров, попутно вводя базовые свойства, которые помогут в написании определения в дальнейшем.

Для начала рассмотрим наиболее распространённую задачу вычисления функций. Имеется некоторая функция $f: x \mapsto f(x)$, которая переводит элементы множества входов в множество результатов с помощью некоторого алгоритма.

Мы предполагаем, что алгоритм действует на некотором \textit{конструктивном множестве}. Чаще всего мы будем говорить о мн-ве $\N$.

\definition{Функция называется вычислимой, если для неё существует некоторый алгоритм вычисления.}

\definition{Конструктивное множество --- множество, для которого есть вычислимая биекция с множеством натуральных чисел.}

Классическим примером задач на вычисление функций является задача на разрешимость диофантова уравнения. Ранее мы уже обсуждали решение \textit{линейных диофантовых уравнений}, являющееся, вообще говоря, частным случаем. Однако, начиная с третьей степени, не представляется возможным привести формулу для решения. Остаётся только алгоритмическое построение.

Итак, существует многочлен $f(x_1 \ldots x_n) = 0$ от произвольного количества переменных. Требуется привести такой алгоритм, у которого:

На вход подаются: последовательности натуральных чисел $\N^*$.

На выходе: $\{0,1\}$. $1$ --- если решение диофантова уравнения существует, $0$ --- если решений (в целых числах) нет.
В качестве решения может быть предложен алгоритм на странице
\pageref{algo:dioffsolve} (алгоритм \ref{algo:dioffsolve}).
\begin{algorithm}[!htp]
\caption{Алгоритм проверки разрешимости диофантового уравнения}
\label{algo:dioffsolve}
\begin{algorithmic}[1]
\Function{SolveEquation}{}
    \For{$i := 0 \ldots \infty$}
        \State $x \gets \pi(t)$
        \If{$f(x) = 0$} 
            \State \Return 1
        \EndIf
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

В итоге получили:
\[
    A(f) = 
    \begin{cases}
        1, f(x_1 \ldots x_n) \text{ разрешимо} \\
        \text{иначе не определена}
    \end{cases}
\]

Однако можно заметить, что получена не та функция, которая нужна.
Почему так? Всё очень просто, она не возвращает ноль. Например,
для уравнения $x^2 + 1 = 0$ она просто зациклится и ничего
никогда не вернёт.

Здесь введём первое свойство алгоритмов.

\begin{algo1}
Композиция вычислимых функций вычислима.
\end{algo1}
\begin{proof}
Пусть существуют вычислимые функции $f$, переводящая множество входов $X$ в множество выходов $Y$ и $g$, переводящая $Y$ в $Z$.

\[
    \begin{cases}
        f: X \to Y \\
        g: Y \to Z
    \end{cases}
\]

Построить $g \circ f: X \to Z$ достаточно просто. На первом шаге нужно применить функцию $f$. Далее берём множество выходов $f$ и подаём на вход в $g$. На выходе получим некоторое множество выходов $Z$. Вычислимая композиция построена.

\begin{algorithm}
\caption{Алгоритм получения композиции функций}
\begin{algorithmic}[1]
\Function{Composition}{x}
    \State $t \gets f(x)$
    \State \Return $g(t)$
\EndFunction
\end{algorithmic}
\end{algorithm}
\end{proof}

Итак, есть вычислимая биекция $\pi: \N^* \to \N$.

Построим композицию $\N^* \to \N \to \{0, 1\}$.

\[
    \begin{cases}
        \pi^{-1}: B \to A \\
        f: A \to A \\
        \pi: A \to B
    \end{cases}
\]

Построить это можно применением композиции  $\pi \circ f \circ \pi^{-1}$. Получим алгоритм из $B$ в $B$. 
Поэтому нам, по сути, \textbf{без разницы какие множества на входе
и выходе} так как можно получить легко из одного другое.



Заметим, что если некоторая биекция $\pi$ вычислима, то обратная ей $\pi^{-1}$ также будет вычислима. Способ вычисления схож с алгоритмом для диофантовых уравнений.

Рассматриваем все возможные значения входов и вычисляем $\pi^{-1}(x)$.
\begin{algorithm}
\caption{Алгоритм построения обратной функции для биекции}
\begin{algorithmic}[1]
\Function{RevBiection}{x}
    \For{$n := 0 \ldots \infty$}
        \If{$\pi(n) = x$} 
            \State \Return n
        \EndIf
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

Стоит отметить, что данный алгоритм всегда завершается так как
(по определению) биекция сюрьективна и найдется номер $n$ для
которого $\pi(n) = x$.

\subsection*{Задачи разрешения. Разрешимые множества}

Вспомним что такое характеристическая функция множества $S$:
\[
\chi_S(x) = \begin{cases}
    1,\ x \in S \\
    0,\ x \notin S
\end{cases}
\]

\definition{Множество называется разрешимым, если его
характеристическая функция вычислима.}

Понятно, что в таком виде очень удобно исследовать вопросы о
свойствах некоторых объектов (разрешимости диофантовых уравнений,
связность графа и так далее). Поэтому разрешимые множества
очень важный объект.

\statement{Конечное множество $S \subset \N$ всегда разрешимо.}
\begin{proof}
Следующий алгоритм вычисляет характеристическую функцию.

\begin{algorithm}
\caption{Алгоритм разрешения конечного множества}
\begin{algorithmic}[1]
\Function{SolveSet}{s, x}
    \If{$x = s_1$}
        \State \Return 1
    \EndIf
    \State \ldots
    \If{$x = s_n$}
        \State \Return 1
    \EndIf
    \State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}
Стоит отметить, что функция останавливает свою работу после
возвращения значения (как в языке C, например, а не как в Pascal).

По сути мы просто по очереди сравниваем элементы множества
на равенство входному. Их у нас конечное число, а значит и
алгоритм всегда работает конечное время. Поэтому функция вычислима.
\end{proof}

\statement{Если множества $A, B$ разрешимы, то и множества 
$A \cap B$, $A \cup B$, $A \setminus B$, $\N \setminus A$
тоже разрешимы.}
\begin{proof}
Алгоритмы для определения характеристических функций
очень похожи, поэтому будет приведена сначала общая часть
всех алгоритмов.
\begin{algorithm}
\caption{Алгоритм разрешения операций над множествами}
\begin{algorithmic}[1]
\Function{SolveSet}{A, B, x}
    \State $a \gets \chi_A(x)$
    \State $b \gets \chi_B(x)$
    \State \Return \ldots
\EndFunction
\end{algorithmic}
\end{algorithm}
На месте точек должны стоять:
\begin{enumerate}
    \item $a \land b$ для $A \cap B$
    \item $a \lor b$ для $A \cup B$
    \item $a \land \lnot b$ для $A \setminus B$
    \item $\lnot a$ для $\N \setminus A$
\end{enumerate}
Фактически, мы пользуемся свойствами характеристических функций.
\end{proof}

\begin{theorem}
Существует неразрешимое множество.
\end{theorem}
\begin{proof}
    Алгоритмов всего счётное количество, а множество подмножеств
    натуральных чисел континуально, значит такое множество
    действительно существует.
\end{proof}

\subsection*{Алгоритмы перечисления. Перечислимые множества. Теорема Поста}

%Всё ниже -- Вадим.

\definition{Алгоритм перечисления -- такой алгоритм, у которого нет входа, он работает и может выводить некоторые числа, причём все напечатанные числа составляют счетное множество.}

\definitionone{Множество $S$ называется перечислимым, если есть алгоритм перечисления всех его элементов.}

\begin{theorem}

Существует неперечислимое множество.

\end{theorem}

\begin{proof}

Алгоритмов перечисления -- счётное множество, а бесконечных подмножеств множества натуральных чисел несчётное количество (это разность несчётного и счётного множества).

\end{proof}

\definitiontwo{Множество $S$ -- перечислимо, если существует такая вычислимая функция:

\[
    f: \N \to \N
    \begin{cases}
        f(\N) = S \\
        \text{Область определения} \ f \ \text{равна либо} \ \N, \text{либо} \ [n].
    \end{cases}
\]

}

\begin{theorem}

Определения $1$ и $2$ эквивалентны.

\end{theorem}

\begin{proof}
\ 

$\Longrightarrow$
Пусть $A$ -- алгоритм перечисления множества $S$. Тогда возьмём следующий алгоритм $B$: принимает на вход число $n$, запускает алгоритм $A$ и считает, сколько чисел напечатано. Как только вывели $n + 1$ слово -- алгоритм печатает результат.

Покажем, что соблюдаются свойства вычислимой функции:

\begin{enumerate}
    \item $B(n) = S$, так как $\forall \ n \ \exists \ B(n) \Rightarrow 
    \begin{cases}
        \forall \ x \in S \ \exists \ B(x) \\
        \forall \ x \notin S$ никогда не выведет $B(x)
        \end{cases}$
    \item Пусть $S$ -- бесконечное множество, тогда функция, задаваемая $B$, определена везде, значит $dom \ B = \N$. Если $B$ работает на $n$ числах, то алгоритм переберёт их и остановится.
\end{enumerate}

$\Longleftarrow$
Возьмём следующий алгоритм перечисления $B$ для множества $S$:

\begin{algorithm}
\caption{Алгоритм перечисления разрешимого множества}
\begin{algorithmic}[1]
\Function{PrintSet}{S}
    \For{$i := 0 \ldots \infty$}
        \If{$f(i) = 1$} 
            \State \textbf{print} i
        \EndIf
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

Если функция определена для некоторых $n$ чисел, то ровно их он и напечатает. Если $dom \ f = \N$, то алгоритм никогда не остановится, то есть напечатает всю область определения $f$. Значит, существует алгоритм, перечисляющий $S$.

\end{proof}

\begin{poste}

Если множества $A$ и $\overline{A}$ перечислимы, то множество A разрешимо.

\end{poste}

\begin{proof}

Алгоритм разрешения множества $A$ устроен так. Он исполняет
модифицированные алгоритмы перечисления множеств $A$ и $\overline{A}$ параллельно: один шаг работы алгоритма перечисления множества A, затем один шаг работы алгоритма перечисления $\overline{A}$ и так далее.

Вместо того, чтобы печатать очередной элемент, модифицированный алгоритм
перечисления запоминает его в списке элементов множества. (В любой момент исполнения алгоритма такой список конечен.)

Когда один из списков увеличивается, добавленный элемент сравнивается со входом $x$. Если обнаружено вхождение $x$ в список элементов множества $A$, то алгоритм разрешения останавливается и выдаёт результат $1$. Если обнаружено вхождение $x$ в список элементов множества $\overline{A}$, то алгоритм разрешения останавливается и выдаёт результат 0. В остальных случаях продолжается работа алгоритмов перечисления.

Докажем корректность алгоритма. Пусть $x \in A$. Тогда $x$ заведомо не входит в список элементов $\overline{A}$ и результат $0$ невозможен. С другой стороны, рано или поздно $x$ появится в списке элементов $A$, поэтому алгоритм выдаст результат $1$.

Аналогично рассуждаем в случае $x \notin A$.

\end{proof}
    
\end{document}

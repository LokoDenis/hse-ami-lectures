\documentclass[a4paper, 12pt]{article}
\usepackage{cmap}           % Пакет для поиска в полученной пдфке
\usepackage[utf8]{inputenc} % Ззамена кодировки файла на utf8
\usepackage[T2A]{fontenc}   % Подключение кодировки шрифтов
\usepackage[russian]{babel} % Использование русского языка 
\usepackage[left=2cm, right=2cm, top=1cm, bottom=2cm]{geometry} % Изменение размеров полей
\usepackage{indentfirst}    % Красная строка в начале текста
\usepackage{amsmath, amsfonts, amsthm, mathtools, amssymb, icomma, units, yfonts}
\usepackage{amsthm} % Пакет для нормального оформления теорем
\usepackage{algorithmicx, algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{esvect}
\usepackage{enumitem}
\usetikzlibrary{calc,matrix}

%Теоремы
%11.01.2016
\newtheorem*{standartbase}{Теорема о стандартном базисе}
\newtheorem*{fulllemma}{Лемма}
\newtheorem*{sl1}{Следствие 1}
\newtheorem*{sl2}{Следствие 2}
\newtheorem*{monotonousbase}{Теорема о монотонном базисе}
\newtheorem*{scheme}{Утверждение 1}
\newtheorem*{n2}{Утверждение 2}
\newtheorem*{usp-rais}{Теорема Успенского-Райса}
\newtheorem*{rec}{Свойство рекурсии}
\newtheorem*{point}{Теорема о неподвижной точке}


%18.01.2016
\newtheorem*{theorem}{Теорема}

\renewcommand{\qedsymbol}{\textbf{Q.E.D.}}
\newcommand{\definition}{\underline{Определение:} }
\newcommand{\definitionone}{\underline{Определение 1:} }
\newcommand{\definitiontwo}{\underline{Определение 2:} }
\newcommand{\statement}{\underline{Утверждение:} }
\newcommand{\note}{\underline{Замечание:} }
\newcommand{\sign}{\underline{Обозначения:} }
\newcommand{\statements}{\underline{Утверждения:} }

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}



\begin{document}
\title{Дискретная математика. Модуль 3. Лекция 7}
\author{Лекторий ПМИ ФКН 2015-2016\\Гринберг Вадим\\Жижин Пётр\\Пузырев Дмитрий}
\date{22 февраля 2016}

\maketitle

Возвращаясь к материалам предыдущей лекции, там было введено понятие универсальной
функции. Однако непонятны свойства этой функции. Что можно сделать с этой
функцией? Что можно узнать о программе, зная её номер?
Этим и другими вопросами занимается раздел ``Автоматическая обработка программ''.

\note По сравнению с лекцией ход изложения материала был изменён для простоты
письменного изложения.

Перед тем как доказать главную теорему введём несколько определений и докажем несколько
свойств.

\definition{Главная универсальная функция (гёделева) -- такая универсальная функция, 
что для любой вычислимой функции $V(n,\ x)$ существует всюду определённая
вычислимая функция $s(n)$, что:
    \[
        \forall\ n,\ x \Rightarrow V(n,\ x) = U(s(n),\ x).
    \]
}

Неформально это значит, что главная универсальная функция позволяет транслировать
в себя любую другую унивесальная функция. Ну, вот например, есть язык C++, его можно
назвать главной универсальной функцией так как любую программу на другом универсальном
языке можно переписать на C++ автоматически (при помощи \emph{транслятора}).

\begin{point}
    Пусть $U$ -- главная универсальная функция, $h(n)$ -- любая всюду определённая вычислимая функция. Тогда:
    
    \[
        \exists\ q \ : \ U(q,\ x) = U(h(q),\ x).
    \]
\end{point}

Честно сказать, не все учёные понимают эту теорему, однако её можно объяснить неформально
так: для любой программы на любом универсальном языке существует ещё одна программа,
которая делает то же самое (то есть программы совпадают).

\begin{proof}
    Для начала найдем такую функцию $f(p): \forall g(p) - \text{вычислимой } 
    \exists p: f(p) = g(p)$. В действительности, она существует, вот например:
    $f(p) = U(p, p)$. Тогда $g(p)$ тоже имеет какой-то номер $q$ и тогда
    $g(q) = U(q, q) = f(q)$.

    Рассмотрим функцию $V(p, x) = U(f(p), x)$. Тогда $V(p, x)$ -- универсальная,
    ведь если была функция $\varphi$ с номером $k$, тогда в некоторой точке $f(p)$
    принимает значение $k$ и $\varphi(x) = U(f(p), x) = V(p, x)$. 
    Тогда (по определению главной универсальной функции) $V(p, x) = U(s(p), x)$.

    Соберём все вместе и получим: $U(f(p), x) = V(p, x) = U(s(p), x)$. Заметим,
    что $f(p)$ не обязана быть всюдуопределённой, а $s(p)$ уже всюдуопределена.

    Тогда вспомним про нашу функцию $h(n)$ из условия и введём функцию $g(p) = h(s(p))$.
    Тогда (по построению функции $f$): $\exists p : g(p) = f(p)$.

    Опять же, собираем всё вместе:
    \[
    \exists p : U(s(p), x) = V(p, x) = U(f(p), x) = U(g(p), x) = U(h(s(p)), x)
    \]
    Пусть $q = s(p)$. Тогда:
    \[
    \exists q : U(q, x) = U(h(q), x)
    \]
\end{proof}

Нам теорема о неподвижной точке нужна только чтобы доказать следующее утверждение:

\begin{rec}
    Для любой вычислимой функции $V(n,\ x)$ и главной универсальной
    функции $U(n, x)$ существует $q$ такое, что:

    \[
        V(q,\ x) = U(q,\ x).
    \]

\end{rec}

\begin{proof}
    Найдем $s(n): V(n, x) = U(s(n), x)$. $s(n)$ -- всюдуопределённая.
    Тогда (по теореме о неподвижной точке)
    $\exists q : V(q, x) = U(s(q), x) = U(q, x)$.
\end{proof}

Теперь главный вопрос: пусть есть некоторое свойство, которое мы хотим проверить
для некоторой функции. 

Перепишем наше условие в более формальном виде:
Пусть $\{f:\N\to\N\}$ -- множество вычислимых функций. 
Разделим его на два непересеающихся подмножества $A$ и $\overline{A}$.
\[
\{f\ |\ f:\N\to\N\} = A \cup \overline{A}
\]
$A$ -- множество тех функций, для которых выполняется свойство,
$\overline{A}$ -- множество тех функций, для которых это не выполняется.

Возьмём некоторую универсальню функцию $U(p,\ x)$.

Обозначим за $P_A$ множество всех $p$ таких, что $U(p,\ x) \in A$.
\[
P_A = \{p\ |\ U(p, x) \in A\}
\]


Тогда вопрос можно поставить так: разрешимо ли множество
программ, удовлетворяющих нашему свойству? На этот вопрос и отвечает теорема
Успенского-Райса.
\begin{usp-rais}
   Если $A$ -- нетривиально ($A \neq \oslash,\ \overline{A} \neq \oslash$), а $U(q,\ x)$ -- главная универсальная функция, то множество $P_A$ неразрешимо.
\end{usp-rais}
Введём для удобства ещё функции $\varepsilon \in \overline{A}$ (нигде не 
определённая) и $\xi \in A$ (какая-то функция, удовлетворяющая условию).
Сделать это можно по аксиоме выбора.

Если $A$ -- это множество нигде не определённых функций, то поменяем их
местами так как $P_A$ разрешимо тогда и только тогда, когда его
дополнение разрешимо.

\begin{proof}[Доказательство 1]
    Пусть $P_A$ разрешимо. Тогда существует всюдуопределённая
    характеристическая функция $\chi_{P_A}$. 
    Построим алгоритм на странице \pageref{algo:usp-rais-proof1} 
    (алгоритм \ref{algo:usp-rais-proof1}).
    \begin{algorithm}
        \caption{Алгоритм, создающий противоречие для разрешимости $P_A$ в док-ве 1}
        \label{algo:usp-rais-proof1}
        \begin{algorithmic}
            \Function{problem}{x}
                \If{$\chi_{P_A}$}
                    \State \Return $\xi(x)$
                \Else 
                    \State \Return $\varepsilon(x)$.
                \EndIf
            \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    Он имеет некоторый номер $p$ (который использован в программе) в $U$.
    \begin{itemize}
            \item $p \in P_A$. Тогда $U_p(x) = \varepsilon(x)$,
                но $\varepsilon(x) \in \overline{A} \implies
                p \notin P_A$. Противоречие.

            \item $p \notin P_A$. Тогда $U_p(x) = \xi(x)$, но
                $\xi(x) \in A \implies p \in P_A$. Противоречие.
    \end{itemize}
    Значит алгоритма разрешения не существует.

    Может показаться, что использование номера программы в ней самой недопустимо,
    однако по свойству рекурсии это делать абсолютно законно.
\end{proof}

\begin{proof}[Доказательство 2]
    Пусть есть алгоритм, который строит алгоритм по номеру из шаблона
    (функция $\varphi : n \mapsto p_n$). Алгоритм выглядит так, как показано
    на странице \pageref{algo:usp-rais-proof2} (алгоритм \ref{algo:usp-rais-proof2}).

    \begin{algorithm}
        \caption{Шаблон алгоритма $p_n$ для функции $\varphi$ в док-ве 2}
        \label{algo:usp-rais-proof2}
        \begin{algorithmic}
            \Function{problem}{x}
                \State $U(n, n)$
                \State \Return $\xi(x)$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    Пусть $H = \{ n\ |\ U(n, n) \text{ останавливается} \}$.
    Рассмотрим два случая:
    \begin{enumerate}
        \item $n \in H \implies U(p_n, x) = \xi(x)$.
        \item $n \notin H \implies U(p_n, x) = \varepsilon(x)$.
    \end{enumerate}
    Что это значит? Это значит, что мы выразили (по факту)
    одну характеристическую функцию через другую:
    \[ \chi_H(n) = (\chi_{P_A} \circ \varphi)(n) \]
    \[ n \in H \iff p_n \in P_A \]

    Если $\chi_{P_A}$ вычислима, то вычислима и $\chi_H$, однако это не так.

    Так как функция $U$ -- главная, то $\varphi$ представима в виде функции
    от двух аргументов $V(n, x)$ (номера шаблона и аргумента).
    \[ U(p_n, x) = V(n, x) = U(s(n), x) \]

    Значит $\chi_{P_A}$ не является вычислимой.

\end{proof}

Мы в доказательстве пользовались тем, что $U(p, x)$ -- главная универсальная
функция. А может быть эта теорема верна вообще для всех универсальных
функций? Но нет, это не так:

\statement Существует универсальная функция $V$ и нетривиальное множество $A$,
что $A$ разрешимо.
\begin{proof}
    Будем пользоваться фактом из Домашнего задания 19 (номер 4):
    множество $Comp \setminus \{\varepsilon(x)\}$ перечислимо.
    $p$ -- номера программ этого множества, а $\widetilde{p}$ -- множество чисел $p$.

    $\widetilde{p} = f(\N)$ -- всюдуопределённой вычислимой (прошлая лекция).

    Введём функцию $V$:
    \[
    V = \begin{cases}
        \text{не определена},\ n = 0 \\
        U(f(n-1), x),\ n > 0
    \end{cases}
    \]
    
    Нетрудно заметить, что $V$ -- универсальная. 

    Пусть $Comp \setminus \{\varepsilon(x)\} = \overline{A} \implies P_A = \{0\}$ 
    -- номер в $V$. А любое конечное множество разрешимо.
\end{proof}

\end{document}
